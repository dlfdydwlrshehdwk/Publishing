<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>3D 지구본 Glow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin:0; padding:0; overflow:hidden; background:#000; }
        #container { width:100vw; height:100vh; }
    </style>
</head>
<body>
<div id="container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
  var scene, camera, renderer, globe, controls;
  var raycaster, mouse, mouse3D;
  var targetPointsMesh = null;
  var globeRayTarget = null;
  var animatedPins = [];

  // 화면용 소프트 그림자 텍스처 (멀티 스톱 알파 그래디언트)
  function makeSoftShadowTex(size) {
    var c = document.createElement('canvas');
    c.width = c.height = size || 512;
    var ctx = c.getContext('2d');

    var cx = c.width / 2, cy = c.height / 2, r = c.width / 2;

    // 알파가 전체 반경에 걸쳐 서서히 떨어지도록 멀티 스톱
    var g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    //    위치    알파
    g.addColorStop(0.00, 'rgba(0,0,0,0.35)'); // 중심 진함
    g.addColorStop(0.40, 'rgba(0,0,0,0.25)');
    g.addColorStop(0.70, 'rgba(0,0,0,0.12)');
    g.addColorStop(0.90, 'rgba(0,0,0,0.05)');
    g.addColorStop(1.00, 'rgba(0,0,0,0.00)'); // 가장자리 0

    ctx.clearRect(0, 0, c.width, c.height);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, c.width, c.height);

    var tex = new THREE.CanvasTexture(c);
    tex.generateMipmaps = false;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.premultiplyAlpha = true;
    tex.needsUpdate = true;
    return tex;
  }

  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    scene.add(new THREE.AmbientLight(0x8e24aa, 0.6));
    var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    var rimLight = new THREE.DirectionalLight(0x9c27b0, 0.8);
    rimLight.position.set(-10, -10, -5);
    scene.add(rimLight);

    // Ray for mouse→globe intersection
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    mouse3D = new THREE.Vector3();

    window.addEventListener('mousemove', function (event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      if (globeRayTarget) {
        var intersects = raycaster.intersectObject(globeRayTarget);
        if (intersects.length > 0) {
          mouse3D.copy(intersects[0].point);
        }
      }
    });

    // Invisible sphere for precise raycast target
    globeRayTarget = new THREE.Mesh(
      new THREE.SphereGeometry(2.5, 32, 32),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    scene.add(globeRayTarget);

    // Load GLB
    var loader = new THREE.GLTFLoader();
    loader.load('../asset/glb/globe.glb', function (gltf) {
      globe = gltf.scene;
      globe.scale.set(5, 5, 5);
      globe.position.set(0, 0, 0);

      // Points: random color, opaque, depth OK
      globe.traverse(function (child) {
        if (child.type === 'Points') {
          targetPointsMesh = child;
          if (child.material) {
            child.material.transparent = false;
            child.material.depthTest = true;
            child.material.depthWrite = true;
            child.material.size = 0.02;
            child.material.sizeAttenuation = true;
            child.material.vertexColors = true;

            var geometry = child.geometry;
            var posAttr = geometry.getAttribute('position');
            var colors = [];
            for (var i = 0; i < posAttr.count; i++) {
              var brightness = Math.random() > 0.33 ? (0.7 + Math.random()*0.3) : (0.1 + Math.random()*0.3);
              colors.push(0.55*brightness, 0.14*brightness, 0.67*brightness);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
          }
          targetPointsMesh.renderOrder = 1;
        }
      });

      // ===== 중앙 80% 오클루더(깊이만 기록) =====
      // 포인트 반지름이 0.51이므로, 80% = 0.51 * 0.8 = 0.408
      var occluderGeom = new THREE.SphereGeometry(0.408, 64, 64);
      var occluderMat  = new THREE.MeshBasicMaterial({
        colorWrite: false,   // 화면엔 색을 아예 안 그림
        depthWrite: true     // 깊이만 기록해서 뒤쪽 반구 점들을 컷
      });
      var occluder80   = new THREE.Mesh(occluderGeom, occluderMat);
      occluder80.renderOrder = -1;         // 포인트보다 먼저
      globe.add(occluder80);

      // ✳ 입체감 셸: 포인트를 가리지 않으면서 조명/림라이트를 받아 볼륨감 추가
      var shellGeom = new THREE.SphereGeometry(0.505, 64, 64); // 포인트(0.51)보다 살짝 작게
      var shellMat  = new THREE.MeshPhongMaterial({
        color: 0x6a1b9a,            // 보라 톤 (원하면 0xffffff로 더 뉴트럴하게)
        emissive: 0x0d0615,         // 아주 약한 자체광
        shininess: 12,              // 하이라이트 약간
        transparent: true,
        opacity: 0.10,              // 0.08~0.14 권장 (너무 진하면 올리고, 과하면 낮추기)
        depthWrite: false,          // 포인트 가리지 않게
        blending: THREE.AdditiveBlending // 어둡게 덮지 않고 밝기만 더함
      });
      var shell = new THREE.Mesh(shellGeom, shellMat);

      // 렌더 순서: 오클루더(-1) < 셸(0) < 포인트(1) < 스프라이트(2) < 핀(3)
      shell.renderOrder = 0;
      globe.add(shell);


      // ===== 화면 기준 블러 '그림자' 스프라이트 =====
      var softTex = makeSoftShadowTex(512);
      var shadowMat = new THREE.SpriteMaterial({
        map: softTex,
        color: 0xffffff,             // 흰색 * 알파 → 검정 텍스처 알파로만 진하기 제어
        transparent: true,
        opacity: 1.0,                // 진하기는 텍스처 알파 스톱으로 이미 조절됨
        blending: THREE.NormalBlending,
        depthTest: false,            // 오버레이
        depthWrite: false,
        alphaTest: 0.0,
        toneMapped: false
      });

      var R_POINTS = 0.51;
      var shadowSprite = new THREE.Sprite(shadowMat);
      shadowSprite.position.set(0, 0, 0);
      var shadowSize = (R_POINTS * 2) * 0.80;    // 지름 80% 영역
      shadowSprite.scale.set(shadowSize, shadowSize, 1);
      shadowSprite.renderOrder = 2;              // 포인트 위로 얹음
      globe.add(shadowSprite);

      // (선택) 가장자리 퍼짐을 살짝 더 주고 싶으면, 아래 한 장 더 (아주 옅게)
      /*
      var featherTex = makeSoftShadowTex(512);
      var featherMat = new THREE.SpriteMaterial({
        map: featherTex,
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,                // 텍스처 알파가 낮으니 이 값 높여도 과하지 않음
        blending: THREE.NormalBlending,
        depthTest: false,
        depthWrite: false,
        toneMapped: false
      });
      var featherSprite = new THREE.Sprite(featherMat);
      featherSprite.scale.set((R_POINTS*2)*0.92, (R_POINTS*2)*0.92, 1);
      featherSprite.position.set(0, 0, 0);
      featherSprite.renderOrder = 2;
      globe.add(featherSprite);
      */

      scene.add(globe);

      // Pins
      addPinAtLatLon(37.57, 127.98, "Seoul");
      addPinAtLatLon(39.8283, -98.5795, "USA");
      addPinAtLatLon(-25.2744, 133.7751, "Australia");
    }, undefined, function (err) {
      console.error('GLB load error:', err);
    });

    window.addEventListener('resize', onResize);
    animate();
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  // Add pin on globe
  function addPinAtLatLon(lat, lon, label) {
    var radius = 0.51;
    var phi = (91 - (lat + 2)) * (Math.PI / 180);
    var theta = (lon + 106) * (Math.PI / 180);

    var x = radius * Math.sin(phi) * Math.cos(theta);
    var y = radius * Math.cos(phi);
    var z = radius * Math.sin(phi) * Math.sin(theta);

    var pinGeometry = new THREE.SphereGeometry(0.005, 16, 16);
    var pinMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0x330000 });
    var pinMesh = new THREE.Mesh(pinGeometry, pinMaterial);
    pinMesh.position.set(x, y, z);

    if (globe) {
      pinMesh.renderOrder = 3; // 스프라이트 위
      globe.add(pinMesh);
    } else {
      console.error('Globe not loaded yet!');
    }

    pinMesh.userData.glowPhase = Math.random();
    animatedPins.push(pinMesh);
  }

  init();
</script>



</body>
</html>
