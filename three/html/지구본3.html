<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>3D 지구본 Glow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin:0; padding:0; overflow:hidden; background:#000; }
        #container { width:100vw; height:100vh; }
    </style>
</head>
<body>
<div id="container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
  var scene, camera, renderer, globe, controls;
  var raycaster, mouse, mouse3D;
  var targetPointsMesh = null;
  var globeRayTarget = null;
  var animatedPins = [];

  // ===== 오오라/코어 전용 텍스처 (중앙은 부드럽게 시작, 바깥은 길게 퍼짐) =====
  function makeAuraTex(size, coreGamma, falloff, centerBoost) {
    const c = document.createElement('canvas');
    c.width = c.height = size || 512;
    const ctx = c.getContext('2d');
    const cx = c.width/2, cy = c.height/2, r = c.width/2;

    const img = ctx.createImageData(c.width, c.height);
    const data = img.data;

    coreGamma   = (coreGamma   == null) ? 1.6 : coreGamma;   // 중심 쪽 곡률
    falloff     = (falloff     == null) ? 2.2 : falloff;     // 바깥 쪽 감쇠
    centerBoost = (centerBoost == null) ? 0.80 : centerBoost;// 중앙 알파 억제(선명한 경계 방지)

    for (let y=0; y<c.height; y++) {
      for (let x=0; x<c.width; x++) {
        const dx = (x + 0.5) - cx;
        const dy = (y + 0.5) - cy;
        const dist = Math.min(1, Math.sqrt(dx*dx + dy*dy) / r); // 0~1

        // 중앙은 천천히 올라오고, 바깥은 길게 떨어지는 커브
        let a = Math.pow(1.0 - dist, falloff); // 0(가)~1(중앙)
        a = Math.pow(a, coreGamma);
        a *= centerBoost;

        const i = (y*c.width + x) * 4;
        data[i+0] = 0;
        data[i+1] = 0;
        data[i+2] = 0;
        data[i+3] = Math.max(0, Math.min(255, a * 255));
      }
    }
    ctx.putImageData(img, 0, 0);

    const tex = new THREE.CanvasTexture(c);
    tex.generateMipmaps = false;
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.premultiplyAlpha = true;
    tex.needsUpdate = true;
    return tex;
  }

  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    scene.add(new THREE.AmbientLight(0x8e24aa, 0.6));
    var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    var rimLight = new THREE.DirectionalLight(0x9c27b0, 0.8);
    rimLight.position.set(-10, -10, -5);
    scene.add(rimLight);

    // Ray for mouse→globe intersection (필요시)
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    mouse3D = new THREE.Vector3();

    window.addEventListener('mousemove', function (event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      if (globeRayTarget) {
        var intersects = raycaster.intersectObject(globeRayTarget);
        if (intersects.length > 0) {
          mouse3D.copy(intersects[0].point);
        }
      }
    });

    // Ray target
    globeRayTarget = new THREE.Mesh(
      new THREE.SphereGeometry(2.5, 32, 32),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    scene.add(globeRayTarget);

    // Load GLB
    var loader = new THREE.GLTFLoader();
    loader.load('../asset/glb/globe.glb', function (gltf) {
      globe = gltf.scene;
      globe.scale.set(5, 5, 5);
      globe.position.set(0, 0, 0);

      // ===== Points: 랜덤 컬러, 불투명, depth 사용 =====
      globe.traverse(function (child) {
        if (child.type === 'Points') {
          targetPointsMesh = child;
          if (child.material) {
            child.material.transparent = false;
            child.material.depthTest = true;
            child.material.depthWrite = true;
            child.material.size = 0.02;
            child.material.sizeAttenuation = true;
            child.material.vertexColors = true;

            var geometry = child.geometry;
            var posAttr = geometry.getAttribute('position');
            var colors = [];
            for (var i = 0; i < posAttr.count; i++) {
              var b = Math.random() > 0.33 ? (0.7 + Math.random()*0.3) : (0.1 + Math.random()*0.3);
              colors.push(0.55*b, 0.14*b, 0.67*b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
          }
          targetPointsMesh.renderOrder = 1;
        }
      });

      // ===== 중앙 80% 오클루더(깊이만 기록) — 뒤쪽 반구 점 컷 =====
      // 포인트 반지름 0.51 → 80% = 0.408
      var occluderGeom = new THREE.SphereGeometry(0.408, 64, 64);
      var occluderMat  = new THREE.MeshBasicMaterial({
        colorWrite: false,
        depthWrite: true
      });
      var occluder80 = new THREE.Mesh(occluderGeom, occluderMat);
      occluder80.renderOrder = -1;   // 오클루더(-1) → 셸(0) → 포인트(1)
      globe.add(occluder80);

      // ===== 입체감 셸 2겹 (Front + Back) — 볼륨/림 하이라이트 =====
      // (1) 안쪽 볼륨 셸
      var shellGeomFront = new THREE.SphereGeometry(0.505, 64, 64);
      var shellMatFront  = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: 0x000000,
        shininess: 18,
        transparent: true,
        opacity: 0.10,              // 0.08~0.14
        depthWrite: false,
        depthTest: true,
        blending: THREE.AdditiveBlending,
        side: THREE.FrontSide
      });
      var shellFront = new THREE.Mesh(shellGeomFront, shellMatFront);
      shellFront.renderOrder = 0;
      globe.add(shellFront);

      // (2) 바깥 림 셸 (BackSide, 살짝 더 큼)
      var shellGeomBack = new THREE.SphereGeometry(0.515, 64, 64);
      var shellMatBack  = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: 0x000000,
        shininess: 20,
        transparent: true,
        opacity: 0.12,              // 0.10~0.18
        depthWrite: false,
        depthTest: true,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide
      });
      shellMatBack.polygonOffset = true;
      shellMatBack.polygonOffsetFactor = 1;
      shellMatBack.polygonOffsetUnits  = 1;

      var shellBack = new THREE.Mesh(shellGeomBack, shellMatBack);
      shellBack.renderOrder = 0;
      globe.add(shellBack);

      // ===== 화면 기준 '코어 + 오오라' 스프라이트 =====
      var R_POINTS = 0.51;

      // (A) 코어: 지름 80% 영역(=검은 중심부). 중앙부터 선명하지 않게!
      var coreTex = makeAuraTex(512, 1.7, 2.2, 0.78);
      var coreMat = new THREE.SpriteMaterial({
        map: coreTex,
        color: 0x000000,
        transparent: true,
        opacity: 1.0,               // 강도는 텍스처 알파가 담당
        blending: THREE.NormalBlending,
        depthTest: false,            // 단순 오버레이
        depthWrite: false,
        toneMapped: false
      });
      var coreSprite = new THREE.Sprite(coreMat);
      coreSprite.position.set(0, 0, 0);
      coreSprite.scale.set((R_POINTS*2)*0.80, (R_POINTS*2)*0.80, 1); // 지름 80%
      coreSprite.renderOrder = 2;   // 포인트 위
      globe.add(coreSprite);

      // (B) 오오라: 80% 바깥~100%까지 은근히 퍼지게(바깥 20%도 영향)
      var auraTex = makeAuraTex(512, 1.0, 3.0, 0.35);
      var auraMat = new THREE.SpriteMaterial({
        map: auraTex,
        color: 0x000000,
        transparent: true,
        opacity: 0.48,              // 0.35~0.55에서 취향 조절
        blending: THREE.NormalBlending,
        depthTest: false,
        depthWrite: false,
        toneMapped: false
      });
      var auraSprite = new THREE.Sprite(auraMat);
      auraSprite.position.set(0, 0, 0);
      auraSprite.scale.set((R_POINTS*2)*1.04, (R_POINTS*2)*1.04, 1); // 지름 약 104% (바깥 20%까지 스며듦)
      auraSprite.renderOrder = 2;
      globe.add(auraSprite);

      scene.add(globe);

      // Pins
      addPinAtLatLon(37.57, 127.98, "Seoul");
      addPinAtLatLon(39.8283, -98.5795, "USA");
      addPinAtLatLon(-25.2744, 133.7751, "Australia");
    }, undefined, function (err) {
      console.error('GLB load error:', err);
    });

    window.addEventListener('resize', onResize);
    animate();
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  // Add pin on globe
  function addPinAtLatLon(lat, lon, label) {
    var radius = 0.51;
    var phi = (91 - (lat + 2)) * (Math.PI / 180);
    var theta = (lon + 106) * (Math.PI / 180);

    var x = radius * Math.sin(phi) * Math.cos(theta);
    var y = radius * Math.cos(phi);
    var z = radius * Math.sin(phi) * Math.sin(theta);

    var pinGeometry = new THREE.SphereGeometry(0.005, 16, 16);
    var pinMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0x330000 });
    var pinMesh = new THREE.Mesh(pinGeometry, pinMaterial);
    pinMesh.position.set(x, y, z);

    if (globe) {
      pinMesh.renderOrder = 3; // 스프라이트 위
      globe.add(pinMesh);
    } else {
      console.error('Globe not loaded yet!');
    }

    pinMesh.userData.glowPhase = Math.random();
    animatedPins.push(pinMesh);
  }

  init();
</script>





</body>
</html>
