<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 지구본 Glow</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, globe, controls;
        let raycaster, mouse, mouse3D;
        let targetPointsMesh = null;
        let globeRayTarget = null; 
        let originalColors = []; 
        let currentGlowStrengths = []; 
        let maxGlowStrengths = []; 
        let animatedPins = [];

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Light
            scene.add(new THREE.AmbientLight(0x8e24aa, 0.6));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            const rimLight = new THREE.DirectionalLight(0x9c27b0, 0.8);
            rimLight.position.set(-10, -10, -5);
            scene.add(rimLight);

            // Ray
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            mouse3D = new THREE.Vector3();

            window.addEventListener('mousemove', function (event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                if (globeRayTarget) {
                    const intersects = raycaster.intersectObject(globeRayTarget);
                    if (intersects.length > 0) {
                        mouse3D.copy(intersects[0].point);
                    }
                }
            });

            // Raycast 전용 invisible globe
            globeRayTarget = new THREE.Mesh(
                new THREE.SphereGeometry(2.5, 32, 32),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            scene.add(globeRayTarget);

            // Load GLB
            const loader = new THREE.GLTFLoader();
            loader.load('../asset/glb/globe.glb', function (gltf) {
                globe = gltf.scene;
                globe.scale.set(5, 5, 5);
                globe.position.set(0, 0, 0);

                globe.traverse(function (child) {
                    if (child.type === 'Points') {
                        targetPointsMesh = child;

                        if (child.material) {
                            child.material.transparent = true;
                            child.material.size = 0.03;
                            child.material.sizeAttenuation = true;
                            child.material.vertexColors = true;

                            const geometry = child.geometry;
                            const posAttr = geometry.getAttribute('position');
                            const colors = [];

                            for (let i = 0; i < posAttr.count; i++) {
                                // 보라색 단색
                                colors.push(0.55, 0.14, 0.67);
                            }

                            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        }
                    }
                });

                scene.add(globe);

                addPinAtLatLon(37.57, 127.98, "Seoul");
                addPinAtLatLon(39.8283, -98.5795, "USA");
                addPinAtLatLon(-25.2744, 133.7751, "Australia");
            }, undefined, function (err) {
                console.error('GLB load error:', err);
            });

            window.addEventListener('resize', onResize);
            animate();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // 핀찍기
        function addPinAtLatLon(lat, lon, label = "pin") {
            const radius = 0.51;

            const phi = (91 - (lat + 2)) * (Math.PI / 180);
            const theta = (lon + 106) * (Math.PI / 180);

            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);

            const pinGeometry = new THREE.SphereGeometry(0.005, 16, 16);
            const pinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xff0000,
                emissive: 0x330000
            });
            const pinMesh = new THREE.Mesh(pinGeometry, pinMaterial);
            
            pinMesh.position.set(x, y, z);

            if (globe) {
                globe.add(pinMesh);
            } else {
                console.error('Globe not loaded yet!');
            }

            pinMesh.userData.glowPhase = Math.random();
            animatedPins.push(pinMesh);
        }

        init();
    </script>
</body>
</html>
