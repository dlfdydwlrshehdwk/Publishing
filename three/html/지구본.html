<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 지구본 Glow</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
  // =========================
  // Config — 테어드롭(빨려드는) 형상 & 연속성 강화
  // =========================
  const CONFIG = {
    // 반경 상한(대권거리 기준): 반구(πR)의 40%
    capArcRatio: 0.40,

    // 테어드롭 비등방성 (탠젠트 평면)
    anisotropy: {
      a_forward: 0.45,  // 위쪽(북극 방향) 더 빠른 감쇠 → 좁음
      a_backward: 0.85, // 아래쪽(반대 방향) 느린 감쇠 → 넓음
      b_perp: 0.70      // 좌우 폭
    },

    // 기본 감쇠 게인
    baseFalloffGain: 1.0,

    // 가장자리 부스트(끝이 살짝 퍼지는 느낌)
    edgeBoost: {
      enable: true,
      startRatio: 0.60, // capArc의 60%부터
      endRatio: 0.95,   // 95%에서 최대
      strength: 0.35
    },

    // 북극 연결 추가광(가늘게 이어짐)
    cone: {
      enable: true,
      allowStart: 0.65, // 마우스 y/R 65%부터
      allowEnd:   0.85, // 85%면 완전 허용
      base: 0.05,
      slope: 0.10,
      falloff: 1.6
    },

    // 전면/남반구 감쇠(형상은 유지, 광량만 억제)
    frontFadeStart: -0.10,
    frontFadeEnd:    0.15,
    southFadeStart: -0.15,
    southFadeEnd:    0.10,

    // 바닥광(최소 밝기): 영향권 내부에서만
    floorInside: 0.020,
    floorPoleExtra: 0.030,

    // Afterglow (연속성↑)
    afterglowDecay: 0.012,
    riseClamp: 0.92,
    influenceThresh: 0.008,

    // 호버 이징: 첫 진입만 150ms 페이드인(이후 1 유지)
    hoverEaseMs: 150,

    // 시간적 스무딩
    pointLerp: 0.18,   // 포인트 강도 수렴
    mouseLerp: 0.20,   // 마우스 3D 위치 EMA

    // 초기 안전장치
    requireFirstHit: true
  };

  // =========================
  // 상태
  // =========================
  let scene, camera, renderer, globe, controls;
  let raycaster, mouse, mouse3D, smoothedMouse3D, hasMouseHit = false;
  let targetPointsMesh = null;
  let globeRayTarget = null;
  let originalColors = [];
  let currentGlowStrengths = [];
  let maxGlowStrengths = [];
  let globeRadiusWorld = 2.5;
  let dynamicDirectionalLight;

  // 호버 이징: 첫 교차 때만 페이드인, 이후 1 유지
  let hoverMix = 0;
  let firstHitTime = 0;

  // =========================
  // Utils
  // =========================
  function smoothstep(edge0, edge1, x) {
    const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
    return t * t * (3 - 2 * t);
  }
  const safe01 = v => (Number.isFinite(v) ? Math.min(1, Math.max(0, v)) : 0);

  // =========================
  // Init
  // =========================
  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    scene.add(new THREE.AmbientLight(0x8e24aa, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);
    const rimLight = new THREE.DirectionalLight(0x9c27b0, 0.8);
    rimLight.position.set(-10, -10, -5);
    scene.add(rimLight);

    dynamicDirectionalLight = new THREE.DirectionalLight(0xffffff, 0);
    dynamicDirectionalLight.position.set(0, 10, 0);
    scene.add(dynamicDirectionalLight);

    // Ray
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    mouse3D = new THREE.Vector3();
    smoothedMouse3D = new THREE.Vector3();

    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      if (globeRayTarget) {
        const intersects = raycaster.intersectObject(globeRayTarget);
        if (intersects.length > 0) {
          mouse3D.copy(intersects[0].point);
          if (!hasMouseHit) {
            hasMouseHit = true;
            firstHitTime = performance.now();
            smoothedMouse3D.copy(mouse3D);
          }
        }
      }
    });

    // Raycast 전용 invisible globe
    globeRayTarget = new THREE.Mesh(
      new THREE.SphereGeometry(globeRadiusWorld, 64, 64),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    scene.add(globeRayTarget);

    // Load GLB
    const loader = new THREE.GLTFLoader();
    loader.load('../asset/glb/globe.glb', (gltf) => {
      globe = gltf.scene;
      globe.scale.set(5, 5, 5);
      globe.position.set(0, 0, 0);

      globe.traverse((child) => {
        if (child.type === 'Points') {
          targetPointsMesh = child;
          if (child.material) {
            child.material.transparent = true;
            child.material.size = 0.03;
            child.material.sizeAttenuation = true;
            child.material.vertexColors = true;

            const geometry = child.geometry;
            const posAttr = geometry.getAttribute('position');
            const colors = [];

            originalColors = [];
            currentGlowStrengths = [];
            maxGlowStrengths = [];

            for (let i = 0; i < posAttr.count; i++) {
              let brightness;
              if (Math.random() > 0.33) brightness = 0.7 + Math.random() * 0.3;
              else brightness = 0.1 + Math.random() * 0.3;

              const r = 0.55 * brightness;
              const g = 0.14 * brightness;
              const b = 0.67 * brightness;

              colors.push(r, g, b);
              originalColors.push(r, g, b);
              currentGlowStrengths.push(0);
              maxGlowStrengths.push(0);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
          }
        }
      });

      scene.add(globe);
    }, undefined, (err) => {
      console.error('GLB load error:', err);
    });

    window.addEventListener('resize', onResize);
    animate();
  }

  // =========================
  // Anisotropic Drop-off (테어드롭 핵심)
  // =========================
  // uMouse, uPoint, uPole: 모두 정규화된 표면 방향 벡터
  function anisotropicDropoff(uMouse, uPoint, uPole, R, params) {
    // 구면 각/호
    const dotClamp = THREE.MathUtils.clamp(uMouse.dot(uPoint), -1, 1);
    const angle = Math.acos(dotClamp);
    const arc = R * angle;

    if (arc === 0) {
      return { glow: 1.0, arc, arcParallel: 0, arcPerp: 0, cosPhi: 1 };
    }

    // mouse 기준 탠젠트 방향: point 쪽
    const d = uPoint.clone().sub(uMouse.clone().multiplyScalar(uPoint.dot(uMouse)));
    const dl2 = d.lengthSq();
    if (dl2 === 0) {
      // 등방성으로 처리 (안전)
      const iso = Math.exp(-((arc / params.b_perp) ** 2)); // ★ 괄호 추가
      return { glow: iso, arc, arcParallel: 0, arcPerp: arc, cosPhi: 0 };
    }
    d.multiplyScalar(1 / Math.sqrt(dl2));

    // mouse 기준 탠젠트 방향: pole(북극) 쪽
    const p = uPole.clone().sub(uMouse.clone().multiplyScalar(uPole.dot(uMouse)));
    const pl2 = p.lengthSq();
    if (pl2 === 0) {
      const iso = Math.exp(-((arc / params.b_perp) ** 2)); // ★ 괄호 추가
      return { glow: iso, arc, arcParallel: 0, arcPerp: arc, cosPhi: 0 };
    }
    p.multiplyScalar(1 / Math.sqrt(pl2));

    // cos(phi) = dot(d, p)  (p가 forward, -p가 backward)
    const cosPhi = THREE.MathUtils.clamp(d.dot(p), -1, 1);
    const arcParallel = arc * Math.abs(cosPhi);
    const arcPerp = Math.sqrt(Math.max(0, arc * arc - arcParallel * arcParallel));

    // forward/backward에 서로 다른 스케일
    const a = (cosPhi >= 0) ? params.a_forward : params.a_backward;
    const b = params.b_perp;

    // 비등방 가우시안
    const term = ((arcParallel / a) ** 2) + ((arcPerp / b) ** 2);
    const glow = Math.exp(-(term)); // ★ -(...) 형태로 안전

    return { glow, arc, arcParallel, arcPerp, cosPhi };
  }

  // =========================
  // Glow Update
  // =========================
  function updateGlowEffect(pointsMesh) {
    if (CONFIG.requireFirstHit && !hasMouseHit) return;

    const geometry  = pointsMesh.geometry;
    const posAttr   = geometry.attributes.position;
    const colorAttr = geometry.attributes.color;
    const glowWhite = new THREE.Color(1, 1, 1);

    // (1) 호버 이징: 첫 진입만 0→1, 이후 유지
    if (hoverMix < 1) {
      const dt = performance.now() - firstHitTime;
      hoverMix = Math.min(1, dt / CONFIG.hoverEaseMs);
    }

    // (2) 마우스 위치 스무딩
    smoothedMouse3D.lerp(mouse3D, CONFIG.mouseLerp);

    const R = globeRadiusWorld;
    const capArc = Math.PI * R * CONFIG.capArcRatio;

    // 단위 벡터들
    const uMouse = smoothedMouse3D.clone().normalize();
    const uPole  = new THREE.Vector3(0, 1, 0); // 월드 북극

    // 캐시
    const tempWorld = new THREE.Vector3();
    const uPoint    = new THREE.Vector3();
    const toCamTmp  = new THREE.Vector3();

    // cone 연결 광을 위한 축
    const topPoint = new THREE.Vector3(0, R + 0.01, 0);
    const dirTopToMouse = smoothedMouse3D.clone().sub(topPoint);
    const dirTopLen2 = dirTopToMouse.lengthSq();
    let allowCone = 0;
    if (CONFIG.cone.enable && dirTopLen2 > 0) {
      dirTopToMouse.multiplyScalar(1 / Math.sqrt(dirTopLen2));
      const mousePolar = THREE.MathUtils.clamp(smoothedMouse3D.y / R, -1, 1);
      allowCone = smoothstep(CONFIG.cone.allowStart, CONFIG.cone.allowEnd, mousePolar);
    }

    // 위도 가중(점 기준)
    function latBlend(yWorld) {
      return smoothstep(-0.20, 0.70, yWorld / R);
    }

    for (let i = 0; i < posAttr.count; i++) {
      tempWorld.fromBufferAttribute(posAttr, i);
      pointsMesh.localToWorld(tempWorld);

      // 단위 표면 법선
      uPoint.copy(tempWorld).normalize();

      // (A) 테어드롭 비등방성 원형 하이라이트 (형태 핵심)
      const A = anisotropicDropoff(uMouse, uPoint, uPole, R, CONFIG.anisotropy);
      let radialGlow = CONFIG.baseFalloffGain * A.glow;

      // 반경 상한(호 길이 cap)
      const arcClampedRatio = Math.min(1, A.arc / capArc);

      // 가장자리 부스트(끝부분 퍼짐)
      if (CONFIG.edgeBoost.enable) {
        const t = smoothstep(CONFIG.edgeBoost.startRatio, CONFIG.edgeBoost.endRatio, arcClampedRatio);
        const edgeGain = 1.0 + CONFIG.edgeBoost.strength * t;
        radialGlow *= edgeGain;
      }

      // (B) 전면/남반구 감쇠(광량만 수정, 형태 유지)
      toCamTmp.copy(camera.position).sub(tempWorld).normalize();
      const frontRaw  = uPoint.dot(toCamTmp); // [-1,1]
      const frontFade = smoothstep(CONFIG.frontFadeStart, CONFIG.frontFadeEnd, frontRaw);
      const southRaw  = tempWorld.y / R;
      const southFade = smoothstep(CONFIG.southFadeStart, CONFIG.southFadeEnd, southRaw);
      radialGlow *= frontFade * southFade;

      // (C) 북극 연결 추가광 (가늘게 이어짐)
      let coneGlow = 0;
      if (allowCone > 0) {
        const toPoint = tempWorld.clone().sub(topPoint);
        const projDist = toPoint.dot(dirTopToMouse);
        if (projDist >= 0) {
          const projected = dirTopToMouse.clone().multiplyScalar(projDist);
          const sideDist  = toPoint.sub(projected).length();
          const coneRadius = CONFIG.cone.base + CONFIG.cone.slope * projDist;
          if (sideDist < coneRadius) {
            const longTerm = (projDist / CONFIG.cone.falloff) ** 2;
            const longFactor = Math.exp(-(longTerm)); // ★ -(...) 형태로 안전
            const sideFactor = 1 - smoothstep(0.0, coneRadius, sideDist);
            const poleW      = latBlend(tempWorld.y);
            const coneSouth  = smoothstep(-0.05, 0.20, tempWorld.y / R);
            coneGlow = longFactor * sideFactor * poleW * allowCone * coneSouth * frontFade;
          }
        }
      }

      // (D) 결합 — 형태는 (A), (C)는 추가 광량
      let combinedGlow = radialGlow + coneGlow;

      // (E) 영향권 내부 바닥광 + 호버 이징
      const inAreaFloor = (A.arc <= capArc) ? (CONFIG.floorInside + CONFIG.floorPoleExtra * latBlend(tempWorld.y)) : 0;
      combinedGlow = Math.max(combinedGlow, inAreaFloor);
      combinedGlow *= hoverMix;

      // (F) Afterglow — 연속성 강화 + 시간적 스무딩
      const inInfluence = (combinedGlow >= CONFIG.influenceThresh) || (A.arc <= capArc * 1.05);
      if (inInfluence) {
        if (combinedGlow > maxGlowStrengths[i]) {
          maxGlowStrengths[i] = Math.min(CONFIG.riseClamp, combinedGlow);
        } else {
          maxGlowStrengths[i] *= (1 - CONFIG.afterglowDecay);
        }
      } else {
        maxGlowStrengths[i] *= (1 - CONFIG.afterglowDecay);
      }

      const target = Math.max(combinedGlow, maxGlowStrengths[i]);
      currentGlowStrengths[i] = currentGlowStrengths[i] + (target - currentGlowStrengths[i]) * CONFIG.pointLerp;

      // (G) 색상 반영
      const baseR = originalColors[i * 3];
      const baseG = originalColors[i * 3 + 1];
      const baseB = originalColors[i * 3 + 2];

      const r = baseR + (1 - baseR) * currentGlowStrengths[i];
      const g = baseG + (1 - baseG) * currentGlowStrengths[i];
      const b = baseB + (1 - baseB) * currentGlowStrengths[i];

      colorAttr.setXYZ(i, safe01(r), safe01(g), safe01(b));
    }

    dynamicDirectionalLight.intensity = 0;
    colorAttr.needsUpdate = true;
  }

  // =========================
  // Renders
  // =========================
  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  function animate() {
    requestAnimationFrame(animate);
    if (globe) globe.rotation.y += 0.001;
    if (targetPointsMesh) updateGlowEffect(targetPointsMesh);
    controls.update();
    renderer.render(scene, camera);
  }

  init();
</script>




</body>
</html>
