<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 지구본 Glow</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    // ====== Config (감각 맞추기 쉬운 파라미터) ======
    const CONFIG = {
        // 원뿔(북극→호버 축) 폭: base + slope * 진행거리
        coneBase: 0.06,
        coneSlope: 0.10,

        // 축(북극→호버 방향) 밝기 감쇠(가우시안 σ)
        coneFalloff: 1.8,

        // 원형(호버 주변) 반경(가우시안 σ)
        radialSigma: 0.9,

        // 위도 블렌딩(북극 강조 ↔ 원형 강조)
        // poleBlend = smoothstep(y0, y1, normalizedY)
        // normalizedY는 [-R, +R] → [0,1]로 매핑한 값
        blendY0: 0.15,
        blendY1: 0.75,

        // 잔상(Afterglow)
        afterglowDecay: 0.025, // 0.02~0.04 권장
        riseClamp: 0.9,        // 최대 상한(잔상 과다 방지)

        // 마우스 교차 전 프레임 차단
        requireFirstHit: true,

        // 반경 최대치: 지구(대권)의 40%를 넘으면 더는 커지지 않음
        capArcRatio: 0.40       // 0.40 * πR (반구의 40%)
    };

    let scene, camera, renderer, globe, controls;
    let raycaster, mouse, mouse3D, hasMouseHit = false;
    let targetPointsMesh = null;
    let globeRayTarget = null; // 마우스 교차용 가짜 구체
    let originalColors = [];   // 원래 랜덤 색상 저장
    let currentGlowStrengths = []; // 각 점의 현재 glow 강도(서서히 변화용)
    let maxGlowStrengths = [];     // 각 점이 받은 최대 glow 강도(잔상용)
    let globeRadiusWorld = 2.5;    // globeRayTarget 반지름과 동일하게 유지
    let dynamicDirectionalLight;   // (참고용) Points에는 영향 미미

    // ----------- 유틸 -----------
    function smoothstep(edge0, edge1, x) {
        const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
    }
    function gaussianFalloff(d, sigma) {
        const s = Math.max(1e-6, sigma);
        const t = d / s;
        return Math.exp(-(t * t));
    }

    function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.getElementById('container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Light
        scene.add(new THREE.AmbientLight(0x8e24aa, 0.6));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);
        const rimLight = new THREE.DirectionalLight(0x9c27b0, 0.8);
        rimLight.position.set(-10, -10, -5);
        scene.add(rimLight);

        // 마우스 위치에 따라 움직이는 디렉셔널 라이트 (참고용)
        dynamicDirectionalLight = new THREE.DirectionalLight(0xffffff, 0);
        dynamicDirectionalLight.position.set(0, 10, 0);
        scene.add(dynamicDirectionalLight);

        // Ray
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        mouse3D = new THREE.Vector3();

        window.addEventListener('mousemove', function (event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            if (globeRayTarget) {
                const intersects = raycaster.intersectObject(globeRayTarget);
                if (intersects.length > 0) {
                    mouse3D.copy(intersects[0].point);
                    hasMouseHit = true;
                }
            }
        });

        // Raycast 전용 invisible globe (교차 정확히 하기 위해)
        globeRayTarget = new THREE.Mesh(
            new THREE.SphereGeometry(globeRadiusWorld, 64, 64),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        scene.add(globeRayTarget);

        // Load GLB
        const loader = new THREE.GLTFLoader();
        loader.load('../asset/glb/globe.glb', function (gltf) {
            globe = gltf.scene;
            globe.scale.set(5, 5, 5);
            globe.position.set(0, 0, 0);

            globe.traverse(function (child) {
                if (child.type === 'Points') {
                    targetPointsMesh = child;

                    if (child.material) {
                        child.material.transparent = true;
                        child.material.size = 0.03;
                        child.material.sizeAttenuation = true;
                        child.material.vertexColors = true;

                        const geometry = child.geometry;
                        const posAttr = geometry.getAttribute('position');
                        const colors = [];

                        originalColors = [];
                        currentGlowStrengths = [];
                        maxGlowStrengths = [];

                        for (let i = 0; i < posAttr.count; i++) {
                            // 밝은 점 2 : 어두운 점 1 비율
                            let brightness;
                            if (Math.random() > 0.33) {
                                brightness = 0.7 + Math.random() * 0.3; // 0.7~1.0
                            } else {
                                brightness = 0.1 + Math.random() * 0.3; // 0.1~0.4
                            }
                            const r = 0.55 * brightness;
                            const g = 0.14 * brightness;
                            const b = 0.67 * brightness;

                            colors.push(r, g, b);
                            originalColors.push(r, g, b);
                            currentGlowStrengths.push(0);
                            maxGlowStrengths.push(0);
                        }

                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    }
                }
            });

            scene.add(globe);
        }, undefined, function (err) {
            console.error('GLB load error:', err);
        });

        window.addEventListener('resize', onResize);
        animate();
    }

    function updateGlowEffect(pointsMesh, mousePosition) {
        // 최초 교차 전이면 업데이트 생략(초기 프레임 “이미 호버됨” 방지)
        if (CONFIG.requireFirstHit && !hasMouseHit) return;

        const geometry = pointsMesh.geometry;
        const posAttr = geometry.attributes.position;
        const colorAttr = geometry.attributes.color;

        const glowWhite = new THREE.Color(1, 1, 1);

        // 캐시 벡터
        const tempWorld = new THREE.Vector3();
        const topPoint  = new THREE.Vector3(0, globeRadiusWorld + 0.01, 0); // 북극점(살짝 바깥)
        const dirTopToMouse = new THREE.Vector3().subVectors(mousePosition, topPoint).normalize();
        const projected = new THREE.Vector3();
        const toPoint = new THREE.Vector3();

        const R = globeRadiusWorld; // 월드 반지름
        const yMin = -R, yMax = R;

        // 위도 기반 블렌딩(0=남극, 1=북극 가깝게)
        function latBlend(yWorld) {
            const normY = (yWorld - yMin) / (yMax - yMin); // [-R, +R] → [0,1]
            return smoothstep(CONFIG.blendY0, CONFIG.blendY1, normY);
        }

        const decay = CONFIG.afterglowDecay;
        const riseCap = CONFIG.riseClamp;

        for (let i = 0; i < posAttr.count; i++) {
            // 월드 좌표로
            tempWorld.fromBufferAttribute(posAttr, i);
            pointsMesh.localToWorld(tempWorld);

            // ---- Cone(북극→호버 축) 성분 ----
            toPoint.subVectors(tempWorld, topPoint); // 북극→점
            const projDist = toPoint.dot(dirTopToMouse); // 축 방향 진행거리(북극에서 얼마나 전진했나)

            let coneGlow = 0;
            if (projDist >= 0) {
                // 축 위의 최근접점
                projected.copy(dirTopToMouse).multiplyScalar(projDist);
                const sideDist = toPoint.distanceTo(projected); // 축에서의 수직 거리

                // 진행거리 따라 원뿔 반경 확장
                const coneRadius = CONFIG.coneBase + CONFIG.coneSlope * projDist;

                if (sideDist < coneRadius) {
                    // 축(길이 방향) 가우시안 감쇠
                    const longFactor = gaussianFalloff(projDist, CONFIG.coneFalloff);

                    // 축에서 벗어나는 거리(반경) 스무스 페이드
                    const sideFactor = 1 - smoothstep(0.0, coneRadius, sideDist);

                    // 원뿔 내부에서만: 두 요소 곱
                    coneGlow = longFactor * sideFactor;
                }
            }

            // ---- Radial(호버 주변 원형) 성분 ----
            const radialDist = tempWorld.distanceTo(mousePosition);
            const radialGlow = gaussianFalloff(radialDist, CONFIG.radialSigma);

            // ---- 위도 기반 블렌딩 ----
            const poleWeight = latBlend(tempWorld.y); // 북쪽일수록 cone 가중 ↑
            const combinedGlow = coneGlow * poleWeight + radialGlow * (1 - poleWeight);

            // ---- 잔상(최대값) 업데이트 ----
            if (combinedGlow > maxGlowStrengths[i]) {
                maxGlowStrengths[i] = Math.min(riseCap, combinedGlow);
            } else {
                maxGlowStrengths[i] *= (1 - decay);
            }

            // 현재 강도 → 목표(즉시 반응) 대신 부드럽게 수렴하려면 여기 보간 추가 가능
            const target = Math.max(combinedGlow, maxGlowStrengths[i]);

            // (옵션) 아주 미세한 저역통과를 원하면 아래 한 줄 사용:
            // currentGlowStrengths[i] += (target - currentGlowStrengths[i]) * 0.08;
            // 아니면 곧바로 타깃을 사용(반응성↑):
            currentGlowStrengths[i] = target;

            // 색 보정
            const baseR = originalColors[i * 3];
            const baseG = originalColors[i * 3 + 1];
            const baseB = originalColors[i * 3 + 2];

            const r = baseR + (glowWhite.r - baseR) * currentGlowStrengths[i];
            const g = baseG + (glowWhite.g - baseG) * currentGlowStrengths[i];
            const b = baseB + (glowWhite.b - baseB) * currentGlowStrengths[i];

            colorAttr.setXYZ(i, r, g, b);
        }

        // Points에는 라이트 영향이 사실상 없으므로 0 유지
        dynamicDirectionalLight.intensity = 0;

        colorAttr.needsUpdate = true;
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // if (globe) globe.rotation.y += 0.001;
        if (targetPointsMesh) updateGlowEffect(targetPointsMesh, mouse3D);

        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>

</body>
</html>
